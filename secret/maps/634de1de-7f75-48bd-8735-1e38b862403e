{"key": "634de1de-7f75-48bd-8735-1e38b862403e", "input": ["induction", "recursion", "time complexity"], "output": {"keyword": "Algorithms", "description": "Algorithms are step-by-step procedures designed to solve specific problems.", "children": [{"keyword": "Algorithm Analysis", "description": "Algorithm Analysis involves analyzing the efficiency and runtime of algorithms.", "children": [{"keyword": "Asymptotic Notation", "description": "Asymptotic Notation is used to describe the time complexity of algorithms.", "children": [{"keyword": "Big O Notation", "description": "..."}, {"keyword": "Omega Notation", "description": "..."}, {"keyword": "Theta Notation", "description": "..."}]}, {"keyword": "Recursion", "description": "Recursion is a programming technique where a function calls itself.", "children": [{"keyword": "Base Case", "description": "..."}, {"keyword": "Recursive Case", "description": "..."}, {"keyword": "Tail Recursion", "description": "..."}]}]}, {"keyword": "Divide and Conquer", "description": "Divide and Conquer is an algorithm design paradigm based on recursively breaking down a problem into two or more sub-problems of the same or related type until they become simple enough to solve directly.", "children": [{"keyword": "Merge Sort", "description": "..."}, {"keyword": "Quick Sort", "description": "..."}, {"keyword": "Binary Search", "description": "..."}]}, {"keyword": "Dynamic Programming", "description": "Dynamic Programming is a method for solving complex problems by breaking them down into simpler subproblems.", "children": [{"keyword": "Memoization", "description": "..."}, {"keyword": "Tabulation", "description": "..."}, {"keyword": "Optimal Substructure", "description": "..."}]}]}}